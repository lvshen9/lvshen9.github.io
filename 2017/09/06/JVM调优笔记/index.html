<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    <meta name="sogou_site_verification" content="true">
    
    
    
    <title>JVM调优笔记 | Lvshen&#39;s Blog | This is My World</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    #<meta name="keywords" content="堆栈,JVM">
    <meta name="baidu-site-verification" content="VIVNdSiMZm" />
    <meta name="description" content="内存分代不同对象的生命周期不同，所以垃圾回收的方式也会不同，这样做是有助于提高回收的效率 虚拟机内存划分为三个代年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation） 其中年轻代与老年代属于堆内存中，垃圾回收主要针对于这两个代 年轻代有一个Eden区和两个或两个以上的Survivor区，对象先存在Eden区，当Eden">
<meta name="keywords" content="堆栈,JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM调优笔记">
<meta property="og:url" content="http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/index.html">
<meta property="og:site_name" content="Lvshen&#39;s Blog">
<meta property="og:description" content="内存分代不同对象的生命周期不同，所以垃圾回收的方式也会不同，这样做是有助于提高回收的效率 虚拟机内存划分为三个代年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation） 其中年轻代与老年代属于堆内存中，垃圾回收主要针对于这两个代 年轻代有一个Eden区和两个或两个以上的Survivor区，对象先存在Eden区，当Eden">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://dl.iteye.com/upload/picture/pic/51401/7b7ece1a-1596-3240-a37d-c3a7d06e2c01.png">
<meta property="og:image" content="http://dl.iteye.com/upload/picture/pic/51403/48059c43-43ff-3d91-8699-78e6ea8af8a6.png">
<meta property="og:image" content="http://dl.iteye.com/upload/picture/pic/51405/dc26b52b-62d5-320d-a627-6a88e6b57d8f.png">
<meta property="og:image" content="http://dl.iteye.com/upload/picture/pic/51407/4e7705f6-75f6-3549-8976-dce68396bbc8.png">
<meta property="og:image" content="http://dl.iteye.com/upload/picture/pic/51409/c9486ed8-90b4-3a46-96f3-7aaa97ace11f.png">
<meta property="og:image" content="http://dl.iteye.com/upload/picture/pic/51413/ece5e1f6-d7a6-3aa6-96d0-5f9d43f69808.png">
<meta property="og:image" content="http://dl.iteye.com/upload/picture/pic/51415/49464252-97ea-3ce2-b433-d9088bafb70a.png">
<meta property="og:updated_time" content="2017-09-06T08:30:49.334Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM调优笔记">
<meta name="twitter:description" content="内存分代不同对象的生命周期不同，所以垃圾回收的方式也会不同，这样做是有助于提高回收的效率 虚拟机内存划分为三个代年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation） 其中年轻代与老年代属于堆内存中，垃圾回收主要针对于这两个代 年轻代有一个Eden区和两个或两个以上的Survivor区，对象先存在Eden区，当Eden">
<meta name="twitter:image" content="http://dl.iteye.com/upload/picture/pic/51401/7b7ece1a-1596-3240-a37d-c3a7d06e2c01.png">
    
    <link rel="shortcut icon" href="/img/mylogo.jpg">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">我的技术小房间</h5>
          <a href="mailto:https://lvshen9.github.io" title="https://lvshen9.github.io" class="mail">https://lvshen9.github.io</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-address-book"></i>
                About
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/collection"  >
                <i class="icon icon-lg icon-apple"></i>
                Collection
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://lvshen9.github.io/" target="_blank" >
                <i class="icon icon-lg icon-wordpress"></i>
                Blog
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/lvshen9" target="_blank" >
                <i class="icon icon-lg icon-github-alt"></i>
                GitHub
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JVM调优笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JVM调优笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-09-06T08:26:29.000Z" itemprop="datePublished" class="page-time">
  2017-09-06
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内存分代"><span class="post-toc-number">1.</span> <span class="post-toc-text">内存分代</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#虚拟机内存划分为三个代"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">虚拟机内存划分为三个代</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#GC类型"><span class="post-toc-number">2.</span> <span class="post-toc-text">GC类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#选择合适的垃圾回收算法"><span class="post-toc-number">3.</span> <span class="post-toc-text">选择合适的垃圾回收算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#串行收集器"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">串行收集器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#并行处理器"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">并行处理器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#并发收集器"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">并发收集器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#关于GC处理器的总结"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">关于GC处理器的总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#堆大小配置"><span class="post-toc-number">4.</span> <span class="post-toc-text">堆大小配置</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#典型设置"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">典型设置</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#回收器的选择"><span class="post-toc-number">5.</span> <span class="post-toc-text">回收器的选择</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#吞吐量优先的并行收集器"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">吞吐量优先的并行收集器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#响应时间优先的并发收集器"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">响应时间优先的并发收集器</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#辅助信息"><span class="post-toc-number">6.</span> <span class="post-toc-text">辅助信息</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#调优原则"><span class="post-toc-number">7.</span> <span class="post-toc-text">调优原则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#年轻代大小选择"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">年轻代大小选择</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#年老代大小选择"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">年老代大小选择</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#较小堆引起的碎片问题"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">较小堆引起的碎片问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#传统垃圾回收存在的问题"><span class="post-toc-number">8.</span> <span class="post-toc-text">传统垃圾回收存在的问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#增量收集"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">增量收集</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#G1算法"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">G1算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#调优工具参考"><span class="post-toc-number">9.</span> <span class="post-toc-text">调优工具参考</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#堆信息查看"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">堆信息查看</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#线程监控"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">线程监控</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#热点分析"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">热点分析</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#快照"><span class="post-toc-number">9.4.</span> <span class="post-toc-text">快照</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#内存泄漏检查"><span class="post-toc-number">9.5.</span> <span class="post-toc-text">内存泄漏检查</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#年老代堆空间被占满"><span class="post-toc-number">9.5.1.</span> <span class="post-toc-text">年老代堆空间被占满</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#持久代被占满"><span class="post-toc-number">9.5.2.</span> <span class="post-toc-text">持久代被占满</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#线程堆栈满"><span class="post-toc-number">9.5.3.</span> <span class="post-toc-text">线程堆栈满</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#系统内存被占满"><span class="post-toc-number">9.5.4.</span> <span class="post-toc-text">系统内存被占满</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-JVM调优笔记"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JVM调优笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-09-06 16:26:29" datetime="2017-09-06T08:26:29.000Z"  itemprop="datePublished">2017-09-06</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h4 id="内存分代"><a href="#内存分代" class="headerlink" title="内存分代"></a>内存分代</h4><p>不同对象的生命周期不同，所以垃圾回收的方式也会不同，这样做是有助于提高回收的效率</p>
<h5 id="虚拟机内存划分为三个代"><a href="#虚拟机内存划分为三个代" class="headerlink" title="虚拟机内存划分为三个代"></a>虚拟机内存划分为三个代</h5><p><strong>年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）</strong></p>
<p>其中<code>年轻代</code>与<code>老年代</code>属于堆内存中，垃圾回收主要针对于这两个代</p>
<p>年轻代有一个Eden区和两个或两个以上的Survivor区，对象先存在Eden区，当Eden区满了后，再存在Survivor区，都满了，说明对象生命周期较长，会存在老年代。</p>
<a id="more"></a>
<h4 id="GC类型"><a href="#GC类型" class="headerlink" title="GC类型"></a>GC类型</h4><p><strong>Scavenge GC</strong>：作用在Eden区，针对于无法在Eden区存活的对象</p>
<p><strong>Full GC</strong>：作用于整个堆；触发<code>Full GC</code>的条件为</p>
<blockquote>
<p>· 年老代（Tenured）被写满</p>
<p>· 持久代（Perm）被写满 </p>
<p>· System.gc()被显示调用 </p>
<p>·上一次GC之后Heap的各域分配策略动态变化</p>
</blockquote>
<h4 id="选择合适的垃圾回收算法"><a href="#选择合适的垃圾回收算法" class="headerlink" title="选择合适的垃圾回收算法"></a>选择合适的垃圾回收算法</h4><h5 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h5><p><strong>单处理器的机器：</strong>选择<code>串行收集器</code>，可以使用-XX:+UseSerialGC打开。</p>
<h5 id="并行处理器"><a href="#并行处理器" class="headerlink" title="并行处理器"></a>并行处理器</h5><p><strong>多线程多处理器机器：</strong>对年轻代进行并行垃圾回收，用-XX:+UseParallelGC.打开；如果对年老代垃圾采用并行收集，用-XX:+UseParallelOldGC打开。</p>
<p>使用-XX:ParallelGCThreads=<n>设置并行垃圾回收的线程数。此值可以设置与机器处理器数量相等。</n></p>
<p>推荐<code>并行收集器</code>配置</p>
<blockquote>
<p><strong>最大垃圾回收暂停:</strong>指定垃圾回收时的最长暂停时间，通过-XX:MaxGCPauseMillis=<n>指定。<n>为毫秒.如果指定了此值的话，堆大小和垃圾回收相关参数会进行调整以达到指定值。设定此值可能会减少应用的吞吐量。</n></n></p>
<p><strong>吞吐量:</strong>吞吐量为垃圾回收时间与非垃圾回收时间的比值，通过-XX:GCTimeRatio=<n>来设定，公式为1/（1+N）。例如，-XX:GCTimeRatio=19时，表示5%的时间用于垃圾回收。默认情况为99，即1%的时间用于垃圾回收。</n></p>
</blockquote>
<h5 id="并发收集器"><a href="#并发收集器" class="headerlink" title="并发收集器"></a>并发收集器</h5><p>保证大部分工作都并发进行（应用不停止），垃圾回收只暂停很少的时间，此收集器适合对响应时间要求比较高的中、大规模应用。使用-XX:+UseConcMarkSweepGC打开。</p>
<p>处理要点：降低垃圾回收是暂停的时间。</p>
<blockquote>
<p>为什么会有停顿？</p>
<p>在每个年老代垃圾回收周期中，在收集初期并发收集器 会对整个应用进行简短的暂停，在收集中还会再暂停一次。第二次暂停会比第一次稍长，在此过程中多个线程同时进行垃圾回收工作。</p>
</blockquote>
<p><strong>浮动垃圾：</strong>有些垃圾可能在垃圾回收运行之后产生，这样的垃圾称为浮动垃圾，这些垃圾要在下个周期才能被处理。所以并发收集器需要有20%的空间来处理这些垃圾。</p>
<p><strong>Concurrent Mode Failure：</strong>如果再回收垃圾时，堆没有足够的空间，并发模式失败，应用会被停止，只进行垃圾回收。</p>
<blockquote>
<p>如何解决Concurrent Mode Failure?</p>
<p>通过设置-XX:CMSInitiatingOccupancyFraction=<n>指定还有多少剩余堆时开始执行并发收集</n></p>
</blockquote>
<h5 id="关于GC处理器的总结"><a href="#关于GC处理器的总结" class="headerlink" title="关于GC处理器的总结"></a>关于GC处理器的总结</h5><p><strong>串行处理器：</strong></p>
<p>–适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。<br>–缺点：只能用于小型应用</p>
<p><strong>并行处理器：</strong></p>
<p>–适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。<br>–缺点：垃圾收集过程中应用响应时间可能加长</p>
<p><strong>并发处理器：</strong></p>
<p>–适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。</p>
<p><strong>针对垃圾回收算法，可以有以下的推荐配置</strong></p>
<h4 id="堆大小配置"><a href="#堆大小配置" class="headerlink" title="堆大小配置"></a>堆大小配置</h4><p>JVM最大堆的限制：32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制</p>
<h5 id="典型设置"><a href="#典型设置" class="headerlink" title="典型设置"></a><strong>典型设置</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">java -Xmx3550m -Xms3550m -Xmn2g –Xss128k</div><div class="line"></div><div class="line">-Xmx3550m：设置JVM最大可用内存为3550M。</div><div class="line"></div><div class="line">-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</div><div class="line"></div><div class="line">-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</div><div class="line"></div><div class="line">-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</div><div class="line"></div><div class="line">-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</div><div class="line"></div><div class="line">-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</div><div class="line"></div><div class="line">-XX:MaxPermSize=16m:设置持久代大小为16m。</div><div class="line"></div><div class="line">-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</div></pre></td></tr></table></figure>
<h4 id="回收器的选择"><a href="#回收器的选择" class="headerlink" title="回收器的选择"></a>回收器的选择</h4><h5 id="吞吐量优先的并行收集器"><a href="#吞吐量优先的并行收集器" class="headerlink" title="吞吐量优先的并行收集器"></a>吞吐量优先的并行收集器</h5><p><strong>典型配置</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</div><div class="line"></div><div class="line">-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</div><div class="line"></div><div class="line">-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 </div><div class="line">-XX:+UseParallelOldGC</div><div class="line"></div><div class="line">-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100</div><div class="line"></div><div class="line">-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 </div><div class="line">-XX:+UseAdaptiveSizePolicy</div><div class="line"></div><div class="line">-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</div></pre></td></tr></table></figure>
<h5 id="响应时间优先的并发收集器"><a href="#响应时间优先的并发收集器" class="headerlink" title="响应时间优先的并发收集器"></a>响应时间优先的并发收集器</h5><p><strong>典型配置：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 </div><div class="line">-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</div><div class="line"></div><div class="line">-XX:+UseConcMarkSweepGC：**设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</div><div class="line"></div><div class="line">-XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC </div><div class="line">-XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</div><div class="line"></div><div class="line">-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</div><div class="line"></div><div class="line">-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片。</div></pre></td></tr></table></figure>
<h4 id="辅助信息"><a href="#辅助信息" class="headerlink" title="辅助信息"></a>辅助信息</h4><p>JVM提供了大量命令行参数，打印信息，供调试使用。主要有以下一些：</p>
<p><strong>-XX:+PrintGC：</strong>输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs][Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</p>
<p><strong>-XX:+PrintGCDetails：</strong>输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs][GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</p>
<p><strong>-XX:+PrintGCTimeStamps </strong>-XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用<br>输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</p>
<p><strong>-XX:+PrintGCApplicationConcurrentTime：</strong>打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式：Application time: 0.5291524 seconds</p>
<p><strong>-XX:+PrintGCApplicationStoppedTime：</strong>打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：Total time for which application threads were stopped: 0.0468229 seconds</p>
<p><strong>-XX:PrintHeapAtGC: </strong>打印GC前后的详细堆栈信息。输出形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="number">34.702</span>: [GC &#123;Heap before gc invocations=<span class="number">7</span>:</div><div class="line"></div><div class="line">def <span class="keyword">new</span> generation   total <span class="number">55296</span>K, used <span class="number">52568</span>K [<span class="number">0x1ebd0000</span>, <span class="number">0x227d0000</span>, <span class="number">0x227d0000</span>)</div><div class="line"></div><div class="line">eden space <span class="number">49152</span>K,  <span class="number">99</span>% used [<span class="number">0x1ebd0000</span>, <span class="number">0x21bce430</span>, <span class="number">0x21bd0000</span>)</div><div class="line"></div><div class="line"><span class="keyword">from</span> space <span class="number">6144</span>K,  <span class="number">55</span>% used [<span class="number">0x221d0000</span>, <span class="number">0x22527e10</span>, <span class="number">0x227d0000</span>)</div><div class="line"></div><div class="line">to   space <span class="number">6144</span>K,   <span class="number">0</span>% used [<span class="number">0x21bd0000</span>, <span class="number">0x21bd0000</span>, <span class="number">0x221d0000</span>)</div><div class="line"></div><div class="line">tenured generation   total <span class="number">69632</span>K, used <span class="number">2696</span>K [<span class="number">0x227d0000</span>, <span class="number">0x26bd0000</span>, <span class="number">0x26bd0000</span>)</div><div class="line"></div><div class="line">the space <span class="number">69632</span>K,   <span class="number">3</span>% used [<span class="number">0x227d0000</span>, <span class="number">0x22a720f8</span>, <span class="number">0x22a72200</span>, <span class="number">0x26bd0000</span>)</div><div class="line"></div><div class="line">compacting perm gen  total <span class="number">8192</span>K, used <span class="number">2898</span>K [<span class="number">0x26bd0000</span>, <span class="number">0x273d0000</span>, <span class="number">0x2abd0000</span>)</div><div class="line"></div><div class="line">   the space <span class="number">8192</span>K,  <span class="number">35</span>% used [<span class="number">0x26bd0000</span>, <span class="number">0x26ea4ba8</span>, <span class="number">0x26ea4c00</span>, <span class="number">0x273d0000</span>)</div><div class="line"></div><div class="line">ro space <span class="number">8192</span>K,  <span class="number">66</span>% used [<span class="number">0x2abd0000</span>, <span class="number">0x2b12bcc0</span>, <span class="number">0x2b12be00</span>, <span class="number">0x2b3d0000</span>)</div><div class="line"></div><div class="line">rw space <span class="number">12288</span>K,  <span class="number">46</span>% used [<span class="number">0x2b3d0000</span>, <span class="number">0x2b972060</span>, <span class="number">0x2b972200</span>, <span class="number">0x2bfd0000</span>)</div><div class="line"></div><div class="line"><span class="number">34.735</span>: [DefNew: <span class="number">52568</span>K-&gt;<span class="number">3433</span>K(<span class="number">55296</span>K), <span class="number">0.0072126</span> secs] <span class="number">55264</span>K-&gt;<span class="number">6615</span>K(<span class="number">124928</span>K)Heap after gc invocations=<span class="number">8</span>:</div><div class="line"></div><div class="line">def <span class="keyword">new</span> generation   total <span class="number">55296</span>K, used <span class="number">3433</span>K [<span class="number">0x1ebd0000</span>, <span class="number">0x227d0000</span>, <span class="number">0x227d0000</span>)</div><div class="line"></div><div class="line">eden space <span class="number">49152</span>K,   <span class="number">0</span>% used [<span class="number">0x1ebd0000</span>, <span class="number">0x1ebd0000</span>, <span class="number">0x21bd0000</span>)</div><div class="line"></div><div class="line">  <span class="keyword">from</span> space <span class="number">6144</span>K,  <span class="number">55</span>% used [<span class="number">0x21bd0000</span>, <span class="number">0x21f2a5e8</span>, <span class="number">0x221d0000</span>)</div><div class="line"></div><div class="line">  to   space <span class="number">6144</span>K,   <span class="number">0</span>% used [<span class="number">0x221d0000</span>, <span class="number">0x221d0000</span>, <span class="number">0x227d0000</span>)</div><div class="line"></div><div class="line">tenured generation   total <span class="number">69632</span>K, used <span class="number">3182</span>K [<span class="number">0x227d0000</span>, <span class="number">0x26bd0000</span>, <span class="number">0x26bd0000</span>)</div><div class="line"></div><div class="line">the space <span class="number">69632</span>K,   <span class="number">4</span>% used [<span class="number">0x227d0000</span>, <span class="number">0x22aeb958</span>, <span class="number">0x22aeba00</span>, <span class="number">0x26bd0000</span>)</div><div class="line"></div><div class="line">compacting perm gen  total <span class="number">8192</span>K, used <span class="number">2898</span>K [<span class="number">0x26bd0000</span>, <span class="number">0x273d0000</span>, <span class="number">0x2abd0000</span>)</div><div class="line"></div><div class="line">   the space <span class="number">8192</span>K,  <span class="number">35</span>% used [<span class="number">0x26bd0000</span>, <span class="number">0x26ea4ba8</span>, <span class="number">0x26ea4c00</span>, <span class="number">0x273d0000</span>)</div><div class="line"></div><div class="line">   ro space <span class="number">8192</span>K,  <span class="number">66</span>% used [<span class="number">0x2abd0000</span>, <span class="number">0x2b12bcc0</span>, <span class="number">0x2b12be00</span>, <span class="number">0x2b3d0000</span>)</div><div class="line"></div><div class="line">   rw space <span class="number">12288</span>K,  <span class="number">46</span>% used [<span class="number">0x2b3d0000</span>, <span class="number">0x2b972060</span>, <span class="number">0x2b972200</span>, <span class="number">0x2bfd0000</span>)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">, <span class="number">0.0757599</span> secs]</div></pre></td></tr></table></figure>
<p><strong>-Xloggc:filename:</strong>与上面几个配合使用，把相关日志信息记录到文件以便分析。</p>
<h4 id="调优原则"><a href="#调优原则" class="headerlink" title="调优原则"></a>调优原则</h4><h5 id="年轻代大小选择"><a href="#年轻代大小选择" class="headerlink" title="年轻代大小选择"></a>年轻代大小选择</h5><p><strong>响应时间优先的应用：</strong>尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。</p>
<p><strong>吞吐量优先的应用：</strong>尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。</p>
<h5 id="年老代大小选择"><a href="#年老代大小选择" class="headerlink" title="年老代大小选择"></a>年老代大小选择</h5><p><strong>响应时间优先的应用：</strong>年老代使用并发收集器，所以其大小需要小心设置，一般要考虑<strong>并发会话率</strong>和<strong>会话持续时间</strong>等一些参数。如果堆设置小了，可能会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：</p>
<ol>
<li>并发垃圾收集信息</li>
<li>持久代并发收集次数</li>
<li>传统GC信息</li>
<li>花在年轻代和年老代回收上的时间比例</li>
</ol>
<p>减少年轻代和年老代花费的时间，一般会提高应用的效率</p>
<h5 id="较小堆引起的碎片问题"><a href="#较小堆引起的碎片问题" class="headerlink" title="较小堆引起的碎片问题"></a>较小堆引起的碎片问题</h5><p>因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：</p>
<p>​    1. <strong>-XX:+UseCMSCompactAtFullCollection：</strong>使用并发收集器时，开启对年老代的压缩。</p>
<p>​    2. <strong>-XX:CMSFullGCsBeforeCompaction=0：</strong>上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩</p>
<h4 id="传统垃圾回收存在的问题"><a href="#传统垃圾回收存在的问题" class="headerlink" title="传统垃圾回收存在的问题"></a>传统垃圾回收存在的问题</h4><p>Full GC 会使应用带来暂停。如果应用的实时性要求很高，GC的暂停会带来很大的损失。分代垃圾回收对于应用的暂停处理不尽人意。为了达到实时性的要求。需要新的垃圾回收机制，它需要有如下的功能:</p>
<blockquote>
<p>既支持短的暂停时间，有支持大的内存空间分配</p>
</blockquote>
<h5 id="增量收集"><a href="#增量收集" class="headerlink" title="增量收集"></a>增量收集</h5><p>增量收集的方式在理论上可以解决传统分代方式带来的问题。增量收集把对堆空间划分成一系列内存块，使用时，先使用其中一部分（不会全部用完），垃圾收集时把之前用掉的部分中的存活对象再放到后面没有用的空间中，这样可以实现一直边使用边收集的效果，避免了传统分代方式整个使用完了再暂停的回收的情况。</p>
<p>当然，传统分代收集方式也提供了并发收集，但是他有一个很致命的地方，就是把整个堆做为一个内存块，这样一方面会造成碎片（无法压缩），另一方面他的每次收集都是对整个堆的收集，无法进行选择，在暂停时间的控制上还是很弱。而增量方式，通过内存空间的分块，恰恰可以解决上面问题。</p>
<h5 id="G1算法"><a href="#G1算法" class="headerlink" title="G1算法"></a>G1算法</h5><p>关于增量收集，涉及到Garbage Firest（G1）算法，读者可以参考<a href="http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html" target="_blank" rel="external">这篇文章</a></p>
<p>还是做一个G1算法的简介吧：</p>
<p>他吸取了增量收集优点，把整个堆划分为一个一个等大小的区域（region）。内存的回收和划分都以region为单位；同时，他也吸取了CMS的特点，把这个垃圾回收过程分为几个阶段，分散一个垃圾回收过程；而且，G1也认同分代垃圾回收的思想，认为不同对象的生命周期不同，可以采取不同收集方式，因此，它也支持分代的垃圾回收。为了达到对回收时间的可预计性，G1在扫描了region以后，对其中的活跃对象的大小进行排序，首先会收集那些活跃对象小的region，以便快速回收空间（要复制的活跃对象少了），因为活跃对象小，里面可以认为多数都是垃圾，所以这种方式被称为Garbage First（G1）的垃圾回收算法，即：垃圾优先的回收。</p>
<blockquote>
<p>缺点：在性能上有一些损失</p>
</blockquote>
<p>G1的回收步骤为：</p>
<p>初始标记（Initial Marking）→并发标记（Concurrent Marking）→最终标记暂停（Final Marking Pause）→存活对象计算及清除（Live Data Counting and Cleanup）</p>
<h4 id="调优工具参考"><a href="#调优工具参考" class="headerlink" title="调优工具参考"></a>调优工具参考</h4><p><strong>Jconsole :</strong> jdk自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很详细的跟踪。详细说明参考<a href="http://pengjiaheng.spaces.live.com/blog/cns!2DAA368B386E6AEA!687.entry" target="_blank" rel="external">这里</a></p>
<p><strong>JProfiler</strong>：商业软件，需要付费。功能强大。详细说明参考<a href="http://pengjiaheng.spaces.live.com/blog/cns!2DAA368B386E6AEA!685.entry" target="_blank" rel="external">这里</a></p>
<p><strong>VisualVM</strong>：JDK自带，功能强大，与JProfiler类似。推荐</p>
<p><strong>如何用工具调优</strong></p>
<p>主要观察内存的释放情况</p>
<h5 id="堆信息查看"><a href="#堆信息查看" class="headerlink" title="堆信息查看"></a>堆信息查看</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://dl.iteye.com/upload/picture/pic/51401/7b7ece1a-1596-3240-a37d-c3a7d06e2c01.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>可查看堆空间大小分配（年轻代、年老代、持久代分配）</p>
<p>提供即时的垃圾回收功能</p>
<p>垃圾监控（长时间监控回收情况）</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://dl.iteye.com/upload/picture/pic/51403/48059c43-43ff-3d91-8699-78e6ea8af8a6.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>查看堆内类、对象信息查看：数量、类型等</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://dl.iteye.com/upload/picture/pic/51405/dc26b52b-62d5-320d-a627-6a88e6b57d8f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>对象引用情况查看</p>
</blockquote>
<p>这些工具主要是为了获取堆信息，通过这些信息可以解决以下几个问题：</p>
<blockquote>
<p> 年老代年轻代大小划分是否合理</p>
<p>  内存泄漏</p>
<p>  垃圾回收算法设置是否合理</p>
</blockquote>
<h5 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://dl.iteye.com/upload/picture/pic/51407/4e7705f6-75f6-3549-8976-dce68396bbc8.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>线程信息监控：系统线程数量。</p>
<p>线程状态监控：各个线程都处在什么样的状态下</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://dl.iteye.com/upload/picture/pic/51409/c9486ed8-90b4-3a46-96f3-7aaa97ace11f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>Dump线程详细信息：查看线程内部运行情况</p>
<p>死锁检查</p>
</blockquote>
<h5 id="热点分析"><a href="#热点分析" class="headerlink" title="热点分析"></a>热点分析</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://dl.iteye.com/upload/picture/pic/51413/ece5e1f6-d7a6-3aa6-96d0-5f9d43f69808.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>CPU热点：检查系统哪些方法占用的大量CPU时间</p>
<p>内存热点：检查哪些对象在系统中数量最大（一定时间内存活对象和销毁对象一起统计）</p>
</blockquote>
<h5 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h5><p>快照是系统运行到某一时刻的一个定格。在我们进行调优的时候，不可能用眼睛去跟踪所有系统变化，依赖快照功能，我们就可以进行系统两个不同运行时刻，对象（或类、线程等）的不同，以便快速找到问题</p>
<p>举例说，我要检查系统进行垃圾回收以后，是否还有该收回的对象被遗漏下来的了。那么，我可以在进行<strong>垃圾回收前后</strong>，分别进行一次堆情况的快照，然后对比两次快照的对象情况。</p>
<h5 id="内存泄漏检查"><a href="#内存泄漏检查" class="headerlink" title="内存泄漏检查"></a>内存泄漏检查</h5><p>内存泄漏一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收（或没有回收），从而导致新的资源分配请求无法完成，引起系统错误。</p>
<h6 id="年老代堆空间被占满"><a href="#年老代堆空间被占满" class="headerlink" title="年老代堆空间被占满"></a>年老代堆空间被占满</h6><p><strong>异常：</strong> java.lang.OutOfMemoryError: Java heap space</p>
<p><strong>说明：</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://dl.iteye.com/upload/picture/pic/51415/49464252-97ea-3ce2-b433-d9088bafb70a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>这是最典型的内存泄漏方式，简单说就是所有堆空间都被无法回收的垃圾对象占满，虚拟机无法再在分配新空间。</p>
<p>如上图所示，这是非常典型的内存泄漏的垃圾回收情况图。所有峰值部分都是一次垃圾回收点，所有谷底部分表示是一次垃圾回收后剩余的内存。连接所有谷底的点，可以发现一条由底到高的线，这说明，随时间的推移，系统的堆空间被不断占满，最终会占满整个堆空间。因此可以初步认为系统内部可能有内存泄漏。（上面的图仅供示例，在实际情况下收集数据的时间需要更长，比如几个小时或者几天）</p>
<blockquote>
<p><strong>解决：</strong></p>
<p>​ 一般就是根据垃圾回收前后情况对比，同时根据对象引用情况（常见的集合对象引用）分析，基本都可以找到泄漏点。</p>
</blockquote>
<h6 id="持久代被占满"><a href="#持久代被占满" class="headerlink" title="持久代被占满"></a>持久代被占满</h6><p><strong>异常：</strong>java.lang.OutOfMemoryError: PermGen space</p>
<p><strong>说明：</strong></p>
<p>​    Perm空间被占满。无法为新的class分配存储空间而引发的异常。这个异常以前是没有的，但是在Java反射大量使用的今天这个异常比较常见了。主要原因就是大量动态反射生成的类不断被加载，最终导致Perm区被占满。</p>
<p>​    更可怕的是，不同的classLoader即便使用了相同的类，但是都会对其进行加载，相当于同一个东西，如果有N个classLoader那么他将会被加载N次。因此，某些情况下，这个问题基本视为无解。当然，存在大量classLoader和大量反射类的情况其实也不多。</p>
<blockquote>
<p><strong>解决：</strong></p>
<p>​    1. -XX:MaxPermSize=16m</p>
<p>​    2. 换用JDK。比如JRocket</p>
</blockquote>
<h6 id="线程堆栈满"><a href="#线程堆栈满" class="headerlink" title="线程堆栈满"></a>线程堆栈满</h6><p><strong>异常</strong>：Fatal: Stack size too small</p>
<p><strong>说明</strong>：java中一个线程的空间大小是有限制的。JDK5.0以后这个值是1M。与这个线程相关的数据将会保存在其中。但是当线程空间满了以后，将会出现上面异常。</p>
<blockquote>
<p><strong>解决</strong>：</p>
<p>增加线程栈大小。-Xss2m。但这个配置无法解决根本问题，还要看代码部分是否有造成泄漏的部分。</p>
</blockquote>
<h6 id="系统内存被占满"><a href="#系统内存被占满" class="headerlink" title="系统内存被占满"></a>系统内存被占满</h6><p><strong>异常</strong>：java.lang.OutOfMemoryError: unable to create new native thread</p>
<p><strong>说明</strong>：</p>
<p>​    这个异常是由于操作系统没有足够的资源来产生这个线程造成的。系统创建线程时，除了要在Java堆中分配内存外，操作系统本身也需要分配资源来创建线程。因此，当线程数量大到一定程度以后，堆中或许还有空间，但是操作系统分配不出资源来了，就出现这个异常了。</p>
<p>分配给Java虚拟机的内存愈多，系统剩余的资源就越少，因此，当系统内存固定时，分配给Java虚拟机的内存越多，那么，系统总共能够产生的线程也就越少，两者成反比的关系。同时，可以通过修改-Xss来减少分配给单个线程的空间，也可以增加系统总共内生产的线程数。</p>
<blockquote>
<p><strong>解决：</strong></p>
<p>​    1. 重新设计系统减少线程数量。</p>
<p>​    2. 线程数量不能减少的情况下，通过-Xss减小单个线程大小。以便能生产更多的线程。</p>
</blockquote>
<p>参考资料：</p>
<p><a href="http://pengjiaheng.iteye.com/blog/518623" target="_blank" rel="external">JVM调优总结</a></p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-09-06T08:30:49.334Z" itemprop="dateUpdated">2017-09-06 16:30:49</time>
</span><br>


        
        原文链接：<a href="/2017/09/06/JVM调优笔记/" target="_blank" rel="external">http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/</a>
        
    </div>
    
    <footer>
        <a href="http://lvshen9.gitee.io">
            <img src="/img/avatar.jpg" alt="我的技术小房间">
            我的技术小房间
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/堆栈/">堆栈</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/&title=《JVM调优笔记》 — Lvshen's Blog&pic=http://lvshen9.gitee.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/&title=《JVM调优笔记》 — Lvshen's Blog&source=内存分代不同对象的生命周期不同，所以垃圾回收的方式也会不同，这样做是有助于提高回收的效率
虚拟机内存划分为三个代年轻代（Young Generation）..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JVM调优笔记》 — Lvshen's Blog&url=http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/&via=http://lvshen9.gitee.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/09/08/What-s-Ajax/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">What&#39;s Ajax ?</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/09/05/读书笔记：《锋利的jQuery》/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">读书笔记：《锋利的jQuery》</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "dy9kXHwg5jQUlLryQmpjWRlM-gzGzoHsz",
            appKey: "P9Nh39Ol0JbMMiYqNGHEP3ml",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="https://lvshen9.github.io/blog2/pay/weixin.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="https://lvshen9.github.io/blog2/pay/weixin.jpg" data-alipay="https://lvshen9.github.io/blog2/pay/zhifu.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>我的技术小房间 &copy; 2015 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/&title=《JVM调优笔记》 — Lvshen's Blog&pic=http://lvshen9.gitee.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/&title=《JVM调优笔记》 — Lvshen's Blog&source=内存分代不同对象的生命周期不同，所以垃圾回收的方式也会不同，这样做是有助于提高回收的效率
虚拟机内存划分为三个代年轻代（Young Generation）..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JVM调优笔记》 — Lvshen's Blog&url=http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/&via=http://lvshen9.gitee.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://lvshen9.gitee.io/2017/09/06/JVM调优笔记/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
